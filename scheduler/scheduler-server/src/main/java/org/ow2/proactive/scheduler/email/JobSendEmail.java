package org.ow2.proactive.scheduler.email;

import org.apache.log4j.Logger;
import org.ow2.proactive.scheduler.common.Main;
import org.ow2.proactive.scheduler.common.NotificationData;
import org.ow2.proactive.scheduler.common.SchedulerEvent;
import org.ow2.proactive.scheduler.common.job.JobInfo;
import org.ow2.proactive.scheduler.common.job.JobState;
import org.ow2.proactive.scheduler.core.JobEmailNotificationException;
import org.ow2.proactive.scheduler.core.properties.PASchedulerProperties;
import org.ow2.proactive.scheduler.util.JobLogger;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Enumeration;
import java.util.Properties;

/**
 * Created by leven2 on 16-4-12.
 */
public class JobSendEmail {

    public static final String PROACTIVE_NOTE = "This email was auto-generated by ProActive Scheduling";
    public static final String GENERIC_INFORMATION_KEY_EMAIL = "EMAIL";
    public static final String LOGGER_URL ="http://%s:%s/scheduling-citic/log/job?jobId=%s";
    public static final String REST_CONFIG_PATH = "/config/web/settings.ini";

    private JobState jobState;
    private SchedulerEvent eventType;

    private static final Logger logger = Logger.getLogger(JobSendEmail.class);
    private static final JobLogger jlogger = JobLogger.getInstance();
    private static final String SUBJECT_TEMPLATE = "ProActive Scheduling: job %s(%s) finished";

    public JobSendEmail(JobState js, NotificationData<JobInfo> notification) {
        this.jobState = js;
        this.eventType = notification.getEventType();

    }
    public boolean doCheckAndSend() throws JobEmailNotificationException{
        switch (eventType) {
            case JOB_PENDING_TO_FINISHED:
            case JOB_RUNNING_TO_FINISHED:
            case JOB_LOOP_FINISHED:
                break;
            default:
                logger.trace("Event unrelated to job finish, doing nothing");
                return false;
        }
        if (!PASchedulerProperties.EMAIL_NOTIFICATIONS_ENABLED.getValueAsBoolean()) {
            logger.debug("Notification emails disabled, doing nothing");
            return false;
        }

        ProactiveInfo proactiveInfo = new ProactiveInfo();
        proactiveInfo.setLogUrl(getUrl());
        try {
             proactiveInfo.setHostname(InetAddress.getLocalHost().getCanonicalHostName());
        } catch (UnknownHostException e) {
            logger.debug("Could not get hostname", e);
        }
        proactiveInfo.setNote(PROACTIVE_NOTE);
        proactiveInfo.setVersion(Main.version);
        proactiveInfo.setStatus(jobState.getStatus().toString());
        proactiveInfo.setIssues(jobState.getNumberOfFailedTasks()+jobState.getNumberOfFaultyTasks()+jobState.getNumberOfInErrorTasks());

        SimpleMail.send(getFrom(),getTo(),getSubject(),proactiveInfo);
        return true;
    }

    public void checkAndSend() {
        try {
            boolean sent = doCheckAndSend();
            if (sent) {
                jlogger.info(jobState.getId(), "sent notification email for finished job");
            }
        } catch (JobEmailNotificationException e) {
            jlogger.warn(jobState.getId(), "failed to send email notification: " + e.getMessage());
            logger.trace("Stack trace:", e);
        }
    }

    private static String getFrom() throws JobEmailNotificationException {
        String from = PASchedulerProperties.EMAIL_NOTIFICATIONS_SENDER_ADDRESS.getValueAsString();
        if (from == null || from.isEmpty()) {
            throw new JobEmailNotificationException("Sender address not set in scheduler configuration");
        }
        return from;
    }

    private String getTo() throws JobEmailNotificationException {
        String to = jobState.getGenericInformation().get(GENERIC_INFORMATION_KEY_EMAIL);
        if (to == null) {
            throw new JobEmailNotificationException("Recipient address is not set in generic information");
        }
        return to;
    }

    private String getSubject() {
        String jobID = jobState.getId().value();
        String jobName = jobState.getName();
        return String.format(SUBJECT_TEMPLATE, jobID,jobName);
    }

    private String getUrl(){
        String jobId = jobState.getId().toString();
        Properties properties = readRestProperties();
        return String.format(LOGGER_URL, getIpConfig(), properties.getProperty("web.port", "8080"), jobId);
    }

    private static Properties readRestProperties() {
        File restPropertiesFile = new File(getSchedulerHome() + REST_CONFIG_PATH);
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(restPropertiesFile));
        } catch (IOException e) {
            logger.warn("Could not find REST properties" + restPropertiesFile, e);
        }
        properties.putAll(System.getProperties());
        return properties;
    }

    private static String getSchedulerHome() {
        if (PASchedulerProperties.SCHEDULER_HOME.isSet()) {
            return PASchedulerProperties.SCHEDULER_HOME.getValueAsString();
        } else {
            return ".";
        }
    }

    private static String getIpConfig() {
        StringBuilder ipConfig = new StringBuilder();
        try {
            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) {
                NetworkInterface intf = en.nextElement();
                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) {
                    InetAddress inetAddress = enumIpAddr.nextElement();
                    if (!inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress() && inetAddress.isSiteLocalAddress()) {
                        ipConfig.append(inetAddress.getHostAddress().toString() + "\n");
                    }
                }
            }
        } catch (SocketException e) {
            logger.warn("Could not getIpConfig" + e);
        }
        return ipConfig.toString();
    }
}
